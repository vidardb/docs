{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to VidarDB VidarDB supercharges PostgreSQL analytics. At up to 70 times the intake speeds, data can be available to the analysts in (essentially) real time, with an order of magnitute faster analytic speed. It is actively developed and maintained by VidarDB team.","title":"Welcome to VidarDB"},{"location":"#welcome-to-vidardb","text":"VidarDB supercharges PostgreSQL analytics. At up to 70 times the intake speeds, data can be available to the analysts in (essentially) real time, with an order of magnitute faster analytic speed. It is actively developed and maintained by VidarDB team.","title":"Welcome to VidarDB"},{"location":"data_warehouse/","text":"CREATE DATABASE example; \\c example; CREATE EXTENSION kv_fdw; CREATE SERVER kv_server FOREIGN DATA WRAPPER kv_fdw; CREATE FOREIGN TABLE student(id INTEGER, name TEXT, major TEXT, address TEXT) SERVER kv_server OPTIONS(storage 'column'); INSERT INTO student VALUES(20757123, 'Rafferty', 'Computer Science', 'Waterloo'); INSERT INTO student VALUES(20767234, 'Jones', 'Math', 'Boston'); DELETE FROM student WHERE id=20757123; UPDATE student SET name='Tom' WHERE id=20767234; DROP FOREIGN TABLE student; DROP SERVER kv_server; DROP EXTENSION kv_fdw; \\c postgres DROP DATABASE example;","title":"Data warehouse"},{"location":"example/","text":"VidarDB Examples In this section, we are going to show some basic VidarDB commands and simple interactions with PostgreSQL. Basic Commands To create a database example and switch to it: CREATE DATABASE example; \\c example; Create a new table student using VidarDB's data engine. Claiming EXTENSION and SERVER are needed to trigger VidarDB's engine: CREATE EXTENSION kv_fdw; CREATE SERVER kv_server FOREIGN DATA WRAPPER kv_fdw; CREATE FOREIGN TABLE student(id INTEGER, name TEXT) SERVER kv_server; Let's try to insert some sample data into our new table: INSERT INTO student VALUES(20757123, 'Rafferty'); INSERT INTO student VALUES(20767234, 'Jones'); INSERT INTO student VALUES(20777345, 'Heisenberg'); In the next step, use SELECT statement to query students' information: example=# SELECT * FROM student; id | name ----------+------------ 20767234 | Jones 20777345 | Heisenberg 20757123 | Rafferty (3 rows) Also have a try at DELETE statement: example=# DELETE FROM student WHERE name='Jones'; DELETE 1 example=# SELECT * FROM student; id | name ----------+------------ 20777345 | Heisenberg 20757123 | Rafferty (2 rows) And update 20777345's student name to Tom : example=# UPDATE student SET name='Tom' WHERE id=20777345; UPDATE 1 example=# SELECT * FROM student; id | name ----------+---------- 20777345 | Tom 20757123 | Rafferty (2 rows) Interaction with PostgreSQL VidarDB works seamlessily with the original PostgreSQL. Now, we will create another new table using PostgreSQL's storage engine and add one row into it: CREATE TABLE student_course(id INTEGER, course TEXT); INSERT INTO student_course VALUES(20757123, 'Computer Science'); We currently have something like: example=# SELECT * FROM student_course; id | course ----------+------------------ 20757123 | Computer Science (1 row) Let's try with the JOIN statement with the table student (created by VidarDB engine) and student_course (created by PostgreSQL engine): example=# SELECT student.name FROM student, student_course WHERE student.id = student_course.id; name ---------- Rafferty (1 row) (More examples will come soon!)","title":"VidarDB Examples"},{"location":"example/#vidardb-examples","text":"In this section, we are going to show some basic VidarDB commands and simple interactions with PostgreSQL.","title":"VidarDB Examples"},{"location":"example/#basic-commands","text":"To create a database example and switch to it: CREATE DATABASE example; \\c example; Create a new table student using VidarDB's data engine. Claiming EXTENSION and SERVER are needed to trigger VidarDB's engine: CREATE EXTENSION kv_fdw; CREATE SERVER kv_server FOREIGN DATA WRAPPER kv_fdw; CREATE FOREIGN TABLE student(id INTEGER, name TEXT) SERVER kv_server; Let's try to insert some sample data into our new table: INSERT INTO student VALUES(20757123, 'Rafferty'); INSERT INTO student VALUES(20767234, 'Jones'); INSERT INTO student VALUES(20777345, 'Heisenberg'); In the next step, use SELECT statement to query students' information: example=# SELECT * FROM student; id | name ----------+------------ 20767234 | Jones 20777345 | Heisenberg 20757123 | Rafferty (3 rows) Also have a try at DELETE statement: example=# DELETE FROM student WHERE name='Jones'; DELETE 1 example=# SELECT * FROM student; id | name ----------+------------ 20777345 | Heisenberg 20757123 | Rafferty (2 rows) And update 20777345's student name to Tom : example=# UPDATE student SET name='Tom' WHERE id=20777345; UPDATE 1 example=# SELECT * FROM student; id | name ----------+---------- 20777345 | Tom 20757123 | Rafferty (2 rows)","title":"Basic Commands"},{"location":"example/#interaction-with-postgresql","text":"VidarDB works seamlessily with the original PostgreSQL. Now, we will create another new table using PostgreSQL's storage engine and add one row into it: CREATE TABLE student_course(id INTEGER, course TEXT); INSERT INTO student_course VALUES(20757123, 'Computer Science'); We currently have something like: example=# SELECT * FROM student_course; id | course ----------+------------------ 20757123 | Computer Science (1 row) Let's try with the JOIN statement with the table student (created by VidarDB engine) and student_course (created by PostgreSQL engine): example=# SELECT student.name FROM student, student_course WHERE student.id = student_course.id; name ---------- Rafferty (1 row) (More examples will come soon!)","title":"Interaction with PostgreSQL"},{"location":"faq/","text":"Frequently Asked Questions TBA.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"TBA.","title":"Frequently Asked Questions"},{"location":"run_kmeans_with_vidarDB/","text":"Run KMeans with VidarDB VidarDB natively supports AI, which is built on MADlib allowing you to perfrom various commonly-used AI algorithms in SQL easily. This page gives you a good example of using KMeans clustering algorithm to train data in VidarDB. It assumes VidarDB is already installed. If not, please head over to the Run VidarDB with Docker section. Preparation Make sure psql is installed on your computer. If not, for Debian users: sudo apt-get install postgresql-client Clone and go into the VidarDB's util repository: git clone https://github.com/vidardb/util.git && cd util Import Chicago Taxi Trips data: cd ./util-notebook/kmeans/ && psql -h 127.0.0.1 -p 5432 -U postgres -f ./import-data_chicago_taxi_trips.sql This will also create a new database called chicago_taxi_trips . Then, create a new table chicago_taxi_trips_change for the data training: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS chicago_taxi_trips_change; -- double precision array for (pickup_latitude,pickup_longitude) CREATE TABLE chicago_taxi_trips_change ( row_id SERIAL, taxi_id INT, pickup_latitude DECIMAL(10, 2), pickup_longitude DECIMAL(10, 2), row_vec DOUBLE PRECISION[] ); -- insert data INSERT INTO chicago_taxi_trips_change (taxi_id,pickup_latitude,pickup_longitude, row_vec) SELECT taxi_id, pickup_latitude, pickup_longitude, array_cat(array[pickup_latitude], array[pickup_longitude]) FROM chicago_taxi_trips; Now, the preparation is done. Let's move to the training part. Data Training This section is very simple and straightforward. Before training data, we need to enable AI support in chicago_taxi_trips database, assuming username is postgres without password. We can issue the following command in the shell: docker exec -it vidardb sh -c \"install-madlib.sh -U postgres -D chicago_taxi_trips\" Try the following SQL commands to train data with KMeans: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS km_result; -- run kmeans algorithm CREATE TABLE km_result AS SELECT * FROM madlib.kmeanspp( 'chicago_taxi_trips_change', -- Table of source data 'row_vec', -- Column containing point co-ordinates 5, -- Number of centroids to calculate 'madlib.squared_dist_norm2', -- Distance function 'madlib.avg', -- Aggregate function 20, -- Number of iterations 0.001 -- Fraction of centroids reassigned to keep iterating ); Perform Clustering Predictions Predict the cluster_id of each trip with the model we have just trained: SELECT trips_data.*, (madlib.closest_column(centroids, row_vec)).column_id AS cluster_id FROM chicago_taxi_trips_change AS trips_data, km_result ORDER BY trips_data.row_id DESC LIMIT 10; We can get some results like this: row_id | taxi_id | pickup_latitude | pickup_longitude | row_vec | cluster_id --------+---------+-----------------+------------------+------------------------------+------------ 999 | 7040 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 998 | 7145 | 41.88 | -87.64 | {41.879255084,-87.642648998} | 1 997 | 7864 | 41.79 | -87.75 | {41.785998518,-87.750934289} | 3 996 | 6620 | 41.90 | -87.62 | {41.89503345,-87.619710672} | 0 995 | 393 | 41.89 | -87.63 | {41.892072635,-87.628874157} | 0 994 | 1082 | 41.89 | -87.62 | {41.890922026,-87.618868355} | 0 993 | 55 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 992 | 7749 | 41.89 | -87.63 | {41.892042136,-87.63186395} | 0 991 | 7564 | 41.88 | -87.62 | {41.884987192,-87.620992913} | 0 990 | 7065 | 41.89 | -87.63 | {41.892507781,-87.626214906} | 0 Reference The data this example used come from Taxi Trips | City of Chicago | Data Portal . (More examples will come soon!)","title":"Run KMeans with VidarDB"},{"location":"run_kmeans_with_vidarDB/#run-kmeans-with-vidardb","text":"VidarDB natively supports AI, which is built on MADlib allowing you to perfrom various commonly-used AI algorithms in SQL easily. This page gives you a good example of using KMeans clustering algorithm to train data in VidarDB. It assumes VidarDB is already installed. If not, please head over to the Run VidarDB with Docker section.","title":"Run KMeans with VidarDB"},{"location":"run_kmeans_with_vidarDB/#preparation","text":"Make sure psql is installed on your computer. If not, for Debian users: sudo apt-get install postgresql-client Clone and go into the VidarDB's util repository: git clone https://github.com/vidardb/util.git && cd util Import Chicago Taxi Trips data: cd ./util-notebook/kmeans/ && psql -h 127.0.0.1 -p 5432 -U postgres -f ./import-data_chicago_taxi_trips.sql This will also create a new database called chicago_taxi_trips . Then, create a new table chicago_taxi_trips_change for the data training: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS chicago_taxi_trips_change; -- double precision array for (pickup_latitude,pickup_longitude) CREATE TABLE chicago_taxi_trips_change ( row_id SERIAL, taxi_id INT, pickup_latitude DECIMAL(10, 2), pickup_longitude DECIMAL(10, 2), row_vec DOUBLE PRECISION[] ); -- insert data INSERT INTO chicago_taxi_trips_change (taxi_id,pickup_latitude,pickup_longitude, row_vec) SELECT taxi_id, pickup_latitude, pickup_longitude, array_cat(array[pickup_latitude], array[pickup_longitude]) FROM chicago_taxi_trips; Now, the preparation is done. Let's move to the training part.","title":"Preparation"},{"location":"run_kmeans_with_vidarDB/#data-training","text":"This section is very simple and straightforward. Before training data, we need to enable AI support in chicago_taxi_trips database, assuming username is postgres without password. We can issue the following command in the shell: docker exec -it vidardb sh -c \"install-madlib.sh -U postgres -D chicago_taxi_trips\" Try the following SQL commands to train data with KMeans: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS km_result; -- run kmeans algorithm CREATE TABLE km_result AS SELECT * FROM madlib.kmeanspp( 'chicago_taxi_trips_change', -- Table of source data 'row_vec', -- Column containing point co-ordinates 5, -- Number of centroids to calculate 'madlib.squared_dist_norm2', -- Distance function 'madlib.avg', -- Aggregate function 20, -- Number of iterations 0.001 -- Fraction of centroids reassigned to keep iterating );","title":"Data Training"},{"location":"run_kmeans_with_vidarDB/#perform-clustering-predictions","text":"Predict the cluster_id of each trip with the model we have just trained: SELECT trips_data.*, (madlib.closest_column(centroids, row_vec)).column_id AS cluster_id FROM chicago_taxi_trips_change AS trips_data, km_result ORDER BY trips_data.row_id DESC LIMIT 10; We can get some results like this: row_id | taxi_id | pickup_latitude | pickup_longitude | row_vec | cluster_id --------+---------+-----------------+------------------+------------------------------+------------ 999 | 7040 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 998 | 7145 | 41.88 | -87.64 | {41.879255084,-87.642648998} | 1 997 | 7864 | 41.79 | -87.75 | {41.785998518,-87.750934289} | 3 996 | 6620 | 41.90 | -87.62 | {41.89503345,-87.619710672} | 0 995 | 393 | 41.89 | -87.63 | {41.892072635,-87.628874157} | 0 994 | 1082 | 41.89 | -87.62 | {41.890922026,-87.618868355} | 0 993 | 55 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 992 | 7749 | 41.89 | -87.63 | {41.892042136,-87.63186395} | 0 991 | 7564 | 41.88 | -87.62 | {41.884987192,-87.620992913} | 0 990 | 7065 | 41.89 | -87.63 | {41.892507781,-87.626214906} | 0","title":"Perform Clustering Predictions"},{"location":"run_kmeans_with_vidarDB/#reference","text":"The data this example used come from Taxi Trips | City of Chicago | Data Portal . (More examples will come soon!)","title":"Reference"},{"location":"run_vidarDB_with_docker/","text":"Run VidarDB with Docker We can easily deploy VidarDB with Docker. This section will guide you to install and play with VidarDB in one minute. Requirement Docker is the only requirement. Install it at https://docs.docker.com/get-docker/ . Run a VidarDB's Docker container Before running any of the following commands, please ensure that both the container name vidardb and the port 5432 have not been used in your environment. To run a VidarDB's Docker container: docker run -d --name vidardb -p 5432:5432 vidardb/vidardb:latest After doing that, a vidardb container will start and the database will be initialized. Connect to the VidarDB For the users who don't have the PostgreSQL client installed: docker exec -it vidardb sh -c 'psql -h 127.0.0.1 -p 5432 -U postgres' For the others who have the PostgreSQL client installed: psql -h 127.0.0.1 -p 5432 -U postgres Build your own Docker image You may want to create your custom Docker image. Do it by '1-click' in the root directory of vidardb repository: # Build a Docker image with the default name 'vidardb/vidardb:latest' make docker-image Some available build parameters: REGISTRY=<YOUR REGISTRY ADDRESS> IMAGE=<YOUR IMAGE NAME> TAG=<YOUR IMAGE TAG> make docker-image Enable AI support in your database VidarDB loves AI! Our bulit-in database has already installed MADlib which supports big data machine learning in SQL. If you want to use it in the vidardb container, try the following command: docker exec -it vidardb sh -c \"install-madlib.sh -U <YOUR DATABASE USERNAME> -P <YOUR DATABASE PASSWORD> -D <YOUR DATABASE NAME>\" For example, if you have created a new database named madlib , and the username is madlib and there is no password, then you can simply install madlib like this: docker exec -it vidardb sh -c \"install-madlib.sh -U madlib -D madlib\"","title":"Run VidarDB with Docker"},{"location":"run_vidarDB_with_docker/#run-vidardb-with-docker","text":"We can easily deploy VidarDB with Docker. This section will guide you to install and play with VidarDB in one minute.","title":"Run VidarDB with Docker"},{"location":"run_vidarDB_with_docker/#requirement","text":"Docker is the only requirement. Install it at https://docs.docker.com/get-docker/ .","title":"Requirement"},{"location":"run_vidarDB_with_docker/#run-a-vidardbs-docker-container","text":"Before running any of the following commands, please ensure that both the container name vidardb and the port 5432 have not been used in your environment. To run a VidarDB's Docker container: docker run -d --name vidardb -p 5432:5432 vidardb/vidardb:latest After doing that, a vidardb container will start and the database will be initialized.","title":"Run a VidarDB's Docker container"},{"location":"run_vidarDB_with_docker/#connect-to-the-vidardb","text":"For the users who don't have the PostgreSQL client installed: docker exec -it vidardb sh -c 'psql -h 127.0.0.1 -p 5432 -U postgres' For the others who have the PostgreSQL client installed: psql -h 127.0.0.1 -p 5432 -U postgres","title":"Connect to the VidarDB"},{"location":"run_vidarDB_with_docker/#build-your-own-docker-image","text":"You may want to create your custom Docker image. Do it by '1-click' in the root directory of vidardb repository: # Build a Docker image with the default name 'vidardb/vidardb:latest' make docker-image Some available build parameters: REGISTRY=<YOUR REGISTRY ADDRESS> IMAGE=<YOUR IMAGE NAME> TAG=<YOUR IMAGE TAG> make docker-image","title":"Build your own Docker image"},{"location":"run_vidarDB_with_docker/#enable-ai-support-in-your-database","text":"VidarDB loves AI! Our bulit-in database has already installed MADlib which supports big data machine learning in SQL. If you want to use it in the vidardb container, try the following command: docker exec -it vidardb sh -c \"install-madlib.sh -U <YOUR DATABASE USERNAME> -P <YOUR DATABASE PASSWORD> -D <YOUR DATABASE NAME>\" For example, if you have created a new database named madlib , and the username is madlib and there is no password, then you can simply install madlib like this: docker exec -it vidardb sh -c \"install-madlib.sh -U madlib -D madlib\"","title":"Enable AI support in your database"},{"location":"specification/","text":"Specification This document describes the tech specification of VidarDB. Fast Analytics Of course, performance improvements must be reported using a standard methodology to allow for system to system comparisons. We have executed six of the global standard TPC-H query tests with a 20 GB standard dataset using a commodity laptop. Although only six of the tests are being reported here, others are in progress. The speed improvement varies with the query performed, but the average performance improvement shows a 10 times increase over PostgreSQL alone. To assure an \u2018apples to apples\u2019 comparison, we didn\u2019t build any extra indexes on the data, and used only a single process. These 6 queries contain both scan and join, where we forced both systems to use the widely accepted hash join. The VidarDB extension is much better than the PostgreSQL alone, and the order of magnitude increase in query speed has a direct cost benefit in execution time, hardware cost, and finally labour cost of the analysts creating information from a data set. Fast Data Ingestion Of course, performance improvements must be reported using a standard methodology to allow for system to system comparisons. We have executed the global standard TPC-H data ingestion benchmark tests on both HDD and SSD with randomized input of the lineitem table (the biggest table in the dataset), scaling from 100 MB to 50 GB. With an index on the primary key, B-Tree of PostgreSQL and VidarDB\u2019s patented FADS data structure, we observed that data ingestion is up to 70 and 35 times faster than PostgreSQL for HDD and SSD respectively. VidarDB\u2019s data ingestion speed remained the same throughout the testing, while PostgreSQL\u2019s performance decreases as the dataset grows. Similar results would be observed in other places, as long as the disk side is a bottleneck with growing data amounts. The science behind this dramatic difference is the B-Tree\u2019s delete and rebuild mechanism working to keep the index self balanced during data input. The VidarDB invention does not have any similar limitation to performance. PostgreSQL Extension The design and implementation of VidarDB has followed a principle of complete non-intrusiveness, which means your PostgreSQL remains intact when the VidarDB extension is installed. At the same time, you can benefit from the speed of VidarDB with the familiar PostgreSQL front end. Just think of Chrome and the Chrome extension for ease of understanding. Furthermore, VidarDB is configurable through the same configure file as PostgreSQL. The VidarDB extension can exist in as little as 10 MB on disk and 10 MB in RAM. It can be installed in about 10 minutes. Uninstallation of VidarDB is also easy, needing only 1 minute to remove all traces of VidarDB. Because VidarDB is a PostgreSQL extension, it brings orders of magnitude performance improvement to naked PostgreSQL, while retaining all the familiarity of the existing system. The extension works in deep layers below the human interfaces, so no training period is needed. Efficient Use of Resources There are many relational database management systems (RDBMS) available today. The number of choices is daunting to any business decision-maker. Once a selection is made for a business, the operational staff must make resource decisions to support growth of the data and increased demands of users. One method for increased performance is to scale hardware horizontally by adding additional nodes. The server nodes might be colocated, as in a blade system, or dispersed, perhaps in different geographic regions. There are RDBMS vendors supporting up to 1000 nodes now. Another method for increasing performance is to scale hardware vertically by improving the nodes themselves. The nodes might have upgraded processors, memory, storage disk size or type. Each node in a system might be upgraded. VidarDB\u2019s patented invention was to change the way the database is queried. By installing a database software extension, the data ingestion performance and analytics performance are increased by 70 and 10 times respectively. This software installation is then about equivalent to using 10 nodes in horizontal scaling terms or a mainframe in vertical scaling terms. For an existing data centre, computer hardware is used more efficiently by making the software \u2018smarter\u2019 to provide a 90% reduction in hardware operating cost. Immediacy of Data Analysis Shichao Jin invented our FADS data structure in 2019, and was granted a patent in 2021. It was the first significant invention in the data structure area since the B-Tree 50 years ago. The B-Tree structure is still used by many relational database management systems (RDBMS) today because it is suitable for disk access by extending simple binary tree structures to allow nodes to have more than two children. In most large current data collection and analysis systems, the data are collected all day in an operational database and then copied to an analytic database overnight. Of course, that copy process is very time-consuming where columns of a table are heavily indexed. Our FADS invention enables both very fast data analysis and ingestion without the delays associated with the old structures. Because the VidarDB system ingests data up to 70 times faster, we can imagine dumping data 70 times as often: say, every 20 minutes. Business Intelligence (BI) from an analytic query would have significantly lower latency. It would be approaching real time. As the business world moves more and more toward data-driven decision-making, the currency of BI becomes a key success factor. The length of time we are allowed for decisions has become quite short. So, earlier and faster are better.","title":"Specification"},{"location":"specification/#specification","text":"This document describes the tech specification of VidarDB.","title":"Specification"},{"location":"specification/#fast-analytics","text":"Of course, performance improvements must be reported using a standard methodology to allow for system to system comparisons. We have executed six of the global standard TPC-H query tests with a 20 GB standard dataset using a commodity laptop. Although only six of the tests are being reported here, others are in progress. The speed improvement varies with the query performed, but the average performance improvement shows a 10 times increase over PostgreSQL alone. To assure an \u2018apples to apples\u2019 comparison, we didn\u2019t build any extra indexes on the data, and used only a single process. These 6 queries contain both scan and join, where we forced both systems to use the widely accepted hash join. The VidarDB extension is much better than the PostgreSQL alone, and the order of magnitude increase in query speed has a direct cost benefit in execution time, hardware cost, and finally labour cost of the analysts creating information from a data set.","title":"Fast Analytics"},{"location":"specification/#fast-data-ingestion","text":"Of course, performance improvements must be reported using a standard methodology to allow for system to system comparisons. We have executed the global standard TPC-H data ingestion benchmark tests on both HDD and SSD with randomized input of the lineitem table (the biggest table in the dataset), scaling from 100 MB to 50 GB. With an index on the primary key, B-Tree of PostgreSQL and VidarDB\u2019s patented FADS data structure, we observed that data ingestion is up to 70 and 35 times faster than PostgreSQL for HDD and SSD respectively. VidarDB\u2019s data ingestion speed remained the same throughout the testing, while PostgreSQL\u2019s performance decreases as the dataset grows. Similar results would be observed in other places, as long as the disk side is a bottleneck with growing data amounts. The science behind this dramatic difference is the B-Tree\u2019s delete and rebuild mechanism working to keep the index self balanced during data input. The VidarDB invention does not have any similar limitation to performance.","title":"Fast Data Ingestion"},{"location":"specification/#postgresql-extension","text":"The design and implementation of VidarDB has followed a principle of complete non-intrusiveness, which means your PostgreSQL remains intact when the VidarDB extension is installed. At the same time, you can benefit from the speed of VidarDB with the familiar PostgreSQL front end. Just think of Chrome and the Chrome extension for ease of understanding. Furthermore, VidarDB is configurable through the same configure file as PostgreSQL. The VidarDB extension can exist in as little as 10 MB on disk and 10 MB in RAM. It can be installed in about 10 minutes. Uninstallation of VidarDB is also easy, needing only 1 minute to remove all traces of VidarDB. Because VidarDB is a PostgreSQL extension, it brings orders of magnitude performance improvement to naked PostgreSQL, while retaining all the familiarity of the existing system. The extension works in deep layers below the human interfaces, so no training period is needed.","title":"PostgreSQL Extension"},{"location":"specification/#efficient-use-of-resources","text":"There are many relational database management systems (RDBMS) available today. The number of choices is daunting to any business decision-maker. Once a selection is made for a business, the operational staff must make resource decisions to support growth of the data and increased demands of users. One method for increased performance is to scale hardware horizontally by adding additional nodes. The server nodes might be colocated, as in a blade system, or dispersed, perhaps in different geographic regions. There are RDBMS vendors supporting up to 1000 nodes now. Another method for increasing performance is to scale hardware vertically by improving the nodes themselves. The nodes might have upgraded processors, memory, storage disk size or type. Each node in a system might be upgraded. VidarDB\u2019s patented invention was to change the way the database is queried. By installing a database software extension, the data ingestion performance and analytics performance are increased by 70 and 10 times respectively. This software installation is then about equivalent to using 10 nodes in horizontal scaling terms or a mainframe in vertical scaling terms. For an existing data centre, computer hardware is used more efficiently by making the software \u2018smarter\u2019 to provide a 90% reduction in hardware operating cost.","title":"Efficient Use of Resources"},{"location":"specification/#immediacy-of-data-analysis","text":"Shichao Jin invented our FADS data structure in 2019, and was granted a patent in 2021. It was the first significant invention in the data structure area since the B-Tree 50 years ago. The B-Tree structure is still used by many relational database management systems (RDBMS) today because it is suitable for disk access by extending simple binary tree structures to allow nodes to have more than two children. In most large current data collection and analysis systems, the data are collected all day in an operational database and then copied to an analytic database overnight. Of course, that copy process is very time-consuming where columns of a table are heavily indexed. Our FADS invention enables both very fast data analysis and ingestion without the delays associated with the old structures. Because the VidarDB system ingests data up to 70 times faster, we can imagine dumping data 70 times as often: say, every 20 minutes. Business Intelligence (BI) from an analytic query would have significantly lower latency. It would be approaching real time. As the business world moves more and more toward data-driven decision-making, the currency of BI becomes a key success factor. The length of time we are allowed for decisions has become quite short. So, earlier and faster are better.","title":"Immediacy of Data Analysis"},{"location":"use_cases/","text":"Use Cases The Benefit of Analytic Speed Here are a couple of use cases where query speed improvement should have significant positive business impact. Case 1 A company has created a consumer-facing app. The app uses an API to plug into a cloud-based data warehouse. Queries by consumers submit and return over the 5g web. We know that in recent years, online consumer attention spans have been significantly reduced. We all expect near-instant web-based responses, or we lose patience. If the consumer\u2019s query is not served in <9 seconds (a goldfish\u2019s attention span) it is likely they will abandon the activity, and perhaps the app. Case 2 An in-house analyst at a Fortune 500 company writes a complex query needed to complete a business report. While the query disappears into the ether the analyst grumbles about the bottleneck that consumes 80% of each day and then goes for a coffee to wait. As much as 80% of an analyst\u2019s time can be spent constructing and waiting on queries. If the queries could execute an order of magnitude faster, the analyst would be significantly more productive. Time spent waiting might be effectively eliminated. These are just two data use cases where VidarDB\u2019s patented analytic technology would have significant impact on businesses that use big data analysis within their operations. Of course, the extreme data ingestion speed would support the analytic results being based on real time data too.","title":"Use Cases"},{"location":"use_cases/#use-cases","text":"","title":"Use Cases"},{"location":"use_cases/#the-benefit-of-analytic-speed","text":"Here are a couple of use cases where query speed improvement should have significant positive business impact.","title":"The Benefit of Analytic Speed"},{"location":"use_cases/#case-1","text":"A company has created a consumer-facing app. The app uses an API to plug into a cloud-based data warehouse. Queries by consumers submit and return over the 5g web. We know that in recent years, online consumer attention spans have been significantly reduced. We all expect near-instant web-based responses, or we lose patience. If the consumer\u2019s query is not served in <9 seconds (a goldfish\u2019s attention span) it is likely they will abandon the activity, and perhaps the app.","title":"Case 1"},{"location":"use_cases/#case-2","text":"An in-house analyst at a Fortune 500 company writes a complex query needed to complete a business report. While the query disappears into the ether the analyst grumbles about the bottleneck that consumes 80% of each day and then goes for a coffee to wait. As much as 80% of an analyst\u2019s time can be spent constructing and waiting on queries. If the queries could execute an order of magnitude faster, the analyst would be significantly more productive. Time spent waiting might be effectively eliminated. These are just two data use cases where VidarDB\u2019s patented analytic technology would have significant impact on businesses that use big data analysis within their operations. Of course, the extreme data ingestion speed would support the analytic results being based on real time data too.","title":"Case 2"},{"location":"vidarDB_101/","text":"VidarDB implicitly supports the primary key syntax in SQL. The first attribute in the created table is forced as the primary key in VidarDB, so the value of this attribute should be unique and not null. For example, in the following table student , the attribute id is used as the primary key. CREATE FOREIGN TABLE student( id INTEGER, name TEXT ) SERVER kv_server; If there is no proper attribute that can be used as the primary key, a table needs to add an auto-increment sequence as the first attribute. VidarDB supports the SERIAL or BIGSERIAL type to create an auto-increment sequence. An example is as follows. CREATE FOREIGN TABLE student( id SERIAL, name TEXT ) SERVER kv_server; VidarDB supports the composite type in PostgreSQL. When a composite primary key is required, VidarDB allows multiple attributes to be combined into a composite type. The following example uses such a composite type as the primary key. CREATE TYPE inventory_item AS ( name TEXT, supplier_id INTEGER, price NUMERIC ); CREATE FOREIGN TABLE shop ( item inventory_item, count INTEGER ) SERVER kv_server; INSERT INTO shop VALUES (('fuzzy dice', 42, 1.99), 1000); More information about the composite type can be found in the PostgreSQL documentation","title":"vidarDB 101"},{"location":"what_is_vidarDB/","text":"What is VidarDB This material provides a brief overview of VidarDB. Basic Info VidarDB is a PostgreSQL extension. Its revolutionary Flexible Advanced Data Structure (FADS) enables orders of magnitude speed multiplication for both data ingestion and query execution. The extension requires only 10 MB of disk and 10 MB of RAM for its ten minute, completely non-intrusive installation, which supercharges PostgreSQL system performance. Our extension modifies the performance of layers which are well below the human interface, and so, will seem invisible to the database users. Invisibility means there is no training required to use this remarkable extension. All the benefits of PostgreSQL remain, and users gain the benefits of VidarDB. The performance improvements will speed task execution, supporting business growth while reducing costs. For database systems, faster is better! Target Problem For many decades, analytic queries have accessed data in a B-Tree data structure (a generalization of the binary tree structure). The queries may take a long time to execute, as the data can be spread across multiple tables, or in rows and columns within tables, and there may be GB (TB, PB, \u2026) of data. Of course, Moore\u2019s Law has helped to mask the speed limitations imposed by the antiquated B-Tree data structure, but those year-over-year gains have slowed in recent years. Ever since the invention of the B-Tree in the 1970s, database system designers have tried to speed queries by employing various methods including indexing schemes, horizontal scaling, and vertical scaling. All these solutions are costly in terms of either hardware cost, labour cost, infrastructure cost, or combinations of all of these. Importantly, timeliness of information extracted from the data is one of the costs to a business. The fundamental problem was that the underlying data structure was unwieldy. This was the target problem that launched VidarDB\u2019s development. We sought a solution to the ever-rising cost of a query by changing the data structure used by the query. We invented our revolutionary Flexible Advanced Data Structure (FADS). It is the first major invention in this arena since the 1970s. The new invention affords an order of magnitude speed multiplier in queries and two orders of magnitude in data ingestion. This speed advantage reduces cost in all the cost areas, and orders of magnitude gains in the timeliness of information flowing from the data. Our solution has been three years in development and is at the cusp of market deployment as the core technology of an extension to PostgreSQL. Core Technology Unlike most other databases that almost rely on a data structure designed in the 1970s, VidarDB is built on a revolutionary new Flexible Advanced Data Structure (FADS) that we invented for modern memory hierarchy, efficiently supporting RAM, NVMe, SSD, Disk as well as smooth data flow among these storage tiers. Additionally, it is a versatile, polymorphic data structure, which will adapt to, and optimize for different workloads, such as operational, data analysis, streaming and even a mixture of them. Operational and analytic databases, with their associated tools, have been combined into a single simple system which enables the extreme speed improvements we have reported. The VidarDB core technology exists in software layers well away from the human interfaces of PostgreSQL. As an extension to PostgreSQL, users retain all the benefits of that system, while gaining the speed and simplicity provided by an essentially invisible software layer. VidarDB is not only a storage engine, because it embeds deeply in PostgreSQL and reutilize PostgreSQL\u2019s many components, including SQL interface. Additionally, VidarDB has its own executor based on PostgreSQL\u2019s.","title":"What is VidarDB"},{"location":"what_is_vidarDB/#what-is-vidardb","text":"This material provides a brief overview of VidarDB.","title":"What is VidarDB"},{"location":"what_is_vidarDB/#basic-info","text":"VidarDB is a PostgreSQL extension. Its revolutionary Flexible Advanced Data Structure (FADS) enables orders of magnitude speed multiplication for both data ingestion and query execution. The extension requires only 10 MB of disk and 10 MB of RAM for its ten minute, completely non-intrusive installation, which supercharges PostgreSQL system performance. Our extension modifies the performance of layers which are well below the human interface, and so, will seem invisible to the database users. Invisibility means there is no training required to use this remarkable extension. All the benefits of PostgreSQL remain, and users gain the benefits of VidarDB. The performance improvements will speed task execution, supporting business growth while reducing costs. For database systems, faster is better!","title":"Basic Info"},{"location":"what_is_vidarDB/#target-problem","text":"For many decades, analytic queries have accessed data in a B-Tree data structure (a generalization of the binary tree structure). The queries may take a long time to execute, as the data can be spread across multiple tables, or in rows and columns within tables, and there may be GB (TB, PB, \u2026) of data. Of course, Moore\u2019s Law has helped to mask the speed limitations imposed by the antiquated B-Tree data structure, but those year-over-year gains have slowed in recent years. Ever since the invention of the B-Tree in the 1970s, database system designers have tried to speed queries by employing various methods including indexing schemes, horizontal scaling, and vertical scaling. All these solutions are costly in terms of either hardware cost, labour cost, infrastructure cost, or combinations of all of these. Importantly, timeliness of information extracted from the data is one of the costs to a business. The fundamental problem was that the underlying data structure was unwieldy. This was the target problem that launched VidarDB\u2019s development. We sought a solution to the ever-rising cost of a query by changing the data structure used by the query. We invented our revolutionary Flexible Advanced Data Structure (FADS). It is the first major invention in this arena since the 1970s. The new invention affords an order of magnitude speed multiplier in queries and two orders of magnitude in data ingestion. This speed advantage reduces cost in all the cost areas, and orders of magnitude gains in the timeliness of information flowing from the data. Our solution has been three years in development and is at the cusp of market deployment as the core technology of an extension to PostgreSQL.","title":"Target Problem"},{"location":"what_is_vidarDB/#core-technology","text":"Unlike most other databases that almost rely on a data structure designed in the 1970s, VidarDB is built on a revolutionary new Flexible Advanced Data Structure (FADS) that we invented for modern memory hierarchy, efficiently supporting RAM, NVMe, SSD, Disk as well as smooth data flow among these storage tiers. Additionally, it is a versatile, polymorphic data structure, which will adapt to, and optimize for different workloads, such as operational, data analysis, streaming and even a mixture of them. Operational and analytic databases, with their associated tools, have been combined into a single simple system which enables the extreme speed improvements we have reported. The VidarDB core technology exists in software layers well away from the human interfaces of PostgreSQL. As an extension to PostgreSQL, users retain all the benefits of that system, while gaining the speed and simplicity provided by an essentially invisible software layer. VidarDB is not only a storage engine, because it embeds deeply in PostgreSQL and reutilize PostgreSQL\u2019s many components, including SQL interface. Additionally, VidarDB has its own executor based on PostgreSQL\u2019s.","title":"Core Technology"}]}